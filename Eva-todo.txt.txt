I. Eva Backend Security To-Do List for Solo Developer
HIGH PRIORITY - Essential for Solo User Security
Implement Long-Lived Device Token System

Create a system that issues 1-year tokens for your authorized devices
Include a device validation endpoint to check token validity
Store tokens securely on client devices
Reason: This is your primary security mechanism to ensure only your devices can connect
Implement Initial Device Authentication

Create endpoint that validates a pre-shared secret
Generate device ID and long-lived token upon successful authentication
Include device validation to prevent need for frequent re-authentication
Reason: This establishes the trust relationship with your personal devices
Set Up Secret Manager Integration

Move all sensitive credentials to a cloud secret manager
Implement secret retrieval endpoint that requires valid device token
Reason: Prevents hardcoding sensitive credentials in your application code
Fix JWT Algorithm Enforcement

Ensure all JWT token validation explicitly specifies the algorithm
Always use algorithms=["HS256"] parameter in jwt.decode()
Reason: Prevents algorithm downgrade attacks which are a common JWT vulnerability
Implement Basic Rate Limiting

Add rate limiting specifically to authentication endpoints
Simple implementation to prevent brute force attacks
Reason: Protects your authentication endpoints from automated attacks
Secure Token Storage in Client App

Implement encrypted storage for device tokens on client side
Use EncryptedSharedPreferences (Android) or Keychain (iOS)
Reason: Prevents token theft if device is compromised
MEDIUM PRIORITY - Important But Not Urgent
Reduce JWT Expiration Time with Auto-Refresh

Change token lifetime to a more reasonable period (30-90 days)
Add auto-refresh capability to client application
Reason: Balances security and convenience for solo use
Improve API Error Handling

Standardize error responses across the application
Avoid leaking implementation details in error messages
Reason: Prevents information disclosure that could help attackers
Add Basic Security Headers

Implement essential security headers (HSTS, Content-Security-Policy)
Protect against common web vulnerabilities
Reason: Simple protection against common attack vectors
Restrict CORS Settings

Limit CORS to specific origins needed for your application
Avoid wildcard (*) permissions in production
Reason: Prevents cross-origin attacks while still allowing your applications to work
Implement Token Revocation Mechanism

Add ability to blacklist specific tokens if needed
Simple implementation using Redis
Reason: Provides a way to revoke access if a device is lost or compromised
Add Security Event Logging

Create basic logging for authentication attempts
Log device registrations and token validations
Reason: Helps identify potential unauthorized access attempts
LOW PRIORITY - Nice-to-Have for Solo Projects
Create Settings UI for Token Management

Add interface to view token status
Include manual refresh button
Reason: Provides visibility and control over authentication state
Update Dependencies Regularly

Periodically check and update project dependencies
Manual process is sufficient for solo project
Reason: Ensures you're not using packages with known vulnerabilities
Parameterize Any Direct SQL Queries

Review for and fix any non-parameterized SQL queries
Use SQLAlchemy properly to avoid SQL injection
Reason: Protects against SQL injection if you expand features later
Enhance Password Security (If Using User Authentication)

Implement basic password strength requirements
Only important if you plan to add user accounts beyond your personal access
Reason: Good practice but not critical for device-based auth in solo project
NOT NEEDED FOR SOLO PROJECT
Redis Data Encryption

Unnecessary complexity for solo project
Basic Redis security (auth, firewall) is sufficient
Complex Multi-Factor Authentication

Excessive for personal use
Device-based authentication is adequate security
Advanced Access Control Systems

Unnecessary when you're the only user
Simple token validation is sufficient
Extensive Security Auditing

Disproportionate effort for the risk profile
Basic logging is sufficient
II. Eva Backend Security Flow: After Implementing Changes
1. Initial Application Setup & Authentication
Backend Behavior
Your backend now enforces device-based authentication
Security configuration is loaded from environment variables
Initial device secret is stored as an environment variable in Cloud Run
JWT tokens are properly configured with algorithm enforcement
Rate limiting protects your authentication endpoints
Application Interaction
On first launch, your app checks for a stored device token
Finding none, it prompts for your initial secret (or retrieves it from a secure location you configured)
App sends device information (device ID, model, etc.) along with the initial secret to /authenticate-device
Backend validates the secret and issues a 1-year device token
App stores this token securely in encrypted storage
App now has authorization to access protected endpoints
Code
App → Backend: "Here's my device info and initial secret"
Backend → App: "Validated. Here's your 1-year device token"
2. Accessing Protected Resources
Backend Behavior
Backend requires valid device token for all protected endpoints
Secret values are fetched from Secret Manager, not stored in code
CORS restrictions ensure only your applications can make requests
Security headers protect against common web vulnerabilities
Standardized error responses avoid leaking implementation details
Application Interaction
App retrieves device token from secure storage
App includes token in header for all requests (X-Device-Token)
Token is validated on each request
If accessing secrets, app calls /secrets/{secret_name} endpoint
Backend validates token, retrieves secret, and returns it
App can now use the retrieved secret for service authentication
Code
App → Backend: "I need API_KEY_X" (with device token)
Backend → App: "Here's the requested secret value"
3. Token Validation & Refresh
Backend Behavior
Backend maintains a token blacklist in Redis (empty by default)
/validate-token endpoint checks if a token is still valid
Valid tokens return expiration information
Blacklisted tokens return invalid status
Application Interaction
App periodically validates its token (e.g., on startup, weekly)
If validation successful, app continues using existing token
If validation shows expiration soon, app can proactively refresh
If validation fails, app attempts re-authentication
Code
App → Backend: "Is my token still valid?"
Backend → App: "Yes, valid for another 250 days"

OR

App → Backend: "Is my token still valid?"
Backend → App: "No, token has been revoked"
4. Error Handling & Recovery
Backend Behavior
Authentication failures return standardized 401 responses
Rate limiting prevents brute force attempts
Security events are logged for later review
Error messages are sanitized to avoid revealing implementation details
Application Interaction
App handles authentication errors gracefully
If token becomes invalid, app attempts re-authentication
App implements exponential backoff for repeated failures
App provides clear UI feedback about authentication state
Code
App → Backend: "Request with invalid token"
Backend → App: "401 Unauthorized - Token invalid"
App: *attempts re-authentication*
5. Practical Example Flows
Typical Daily Usage
You open the app
App retrieves stored device token
App makes authenticated requests as needed
Backend validates token and serves resources
All API calls include your device token
Process continues seamlessly without manual authentication
Token Refresh Scenario
App detects token nearing expiration (e.g., 30 days left)
App uses current token to request renewal
Backend validates existing token and issues new token
App stores new token, discards old token
User experiences no disruption
Device Loss Scenario
You realize a device is lost/compromised
You manually add the device token to blacklist via admin endpoint
Lost device can no longer access your backend
Your other devices continue working normally
When you get a new device, you authenticate it with initial secret
Key Differences After Implementation
No hardcoded secrets in your application code
Device-based authentication means only your devices can connect
Long-lived tokens balance security and convenience for solo use
JWT algorithm enforcement prevents common token vulnerabilities
Secret Manager integration keeps sensitive values secure
Simplified error handling prevents information disclosure
Token validation allows you to check status and revoke if needed
This system provides a good security foundation while remaining practical for a personal project. The most significant change is moving from potentially insecure, hardcoded values to a proper device authentication system with secure secret storage.